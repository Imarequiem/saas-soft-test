import { computed, effectScope, getCurrentScope, inject, onScopeDispose, provide, reactive, ref, shallowRef, toRaw, toRef, toRefs, watch, watchEffect } from "./vue.runtime.esm-bundler-CvPjzdzA.js";
import { IN_BROWSER, SUPPORTS_MATCH_MEDIA, SUPPORTS_TOUCH, chunk, clamp, consoleError, consoleWarn, createRange, deprecate, getCurrentInstance, getCurrentInstanceName, getObjectValueByPath, has, mergeDeep, padEnd, propsFactory, toKebabCase } from "./defineComponent-CAKzfwnn.js";

//#region node_modules/vuetify/lib/util/color/APCA.js
/**
* WCAG 3.0 APCA perceptual contrast algorithm from https://github.com/Myndex/SAPC-APCA
* @licence https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
* @see https://www.w3.org/WAI/GL/task-forces/silver/wiki/Visual_Contrast_of_Text_Subgroup
*/
const mainTRC = 2.4;
const Rco = .2126729;
const Gco = .7151522;
const Bco = .072175;
const normBG = .55;
const normTXT = .58;
const revTXT = .57;
const revBG = .62;
const blkThrs = .03;
const blkClmp = 1.45;
const deltaYmin = 5e-4;
const scaleBoW = 1.25;
const scaleWoB = 1.25;
const loConThresh = .078;
const loConFactor = 12.82051282051282;
const loConOffset = .06;
const loClip = .001;
function APCAcontrast(text, background) {
	const Rtxt = (text.r / 255) ** mainTRC;
	const Gtxt = (text.g / 255) ** mainTRC;
	const Btxt = (text.b / 255) ** mainTRC;
	const Rbg = (background.r / 255) ** mainTRC;
	const Gbg = (background.g / 255) ** mainTRC;
	const Bbg = (background.b / 255) ** mainTRC;
	let Ytxt = Rtxt * Rco + Gtxt * Gco + Btxt * Bco;
	let Ybg = Rbg * Rco + Gbg * Gco + Bbg * Bco;
	if (Ytxt <= blkThrs) Ytxt += (blkThrs - Ytxt) ** blkClmp;
	if (Ybg <= blkThrs) Ybg += (blkThrs - Ybg) ** blkClmp;
	if (Math.abs(Ybg - Ytxt) < deltaYmin) return 0;
	let outputContrast;
	if (Ybg > Ytxt) {
		const SAPC = (Ybg ** normBG - Ytxt ** normTXT) * scaleBoW;
		outputContrast = SAPC < loClip ? 0 : SAPC < loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC - loConOffset;
	} else {
		const SAPC = (Ybg ** revBG - Ytxt ** revTXT) * scaleWoB;
		outputContrast = SAPC > -loClip ? 0 : SAPC > -loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC + loConOffset;
	}
	return outputContrast * 100;
}

//#endregion
//#region node_modules/vuetify/lib/util/color/transformCIELAB.js
const delta = .20689655172413793;
const cielabForwardTransform = (t) => t > delta ** 3 ? Math.cbrt(t) : t / (3 * delta ** 2) + 4 / 29;
const cielabReverseTransform = (t) => t > delta ? t ** 3 : 3 * delta ** 2 * (t - 4 / 29);
function fromXYZ$1(xyz) {
	const transform = cielabForwardTransform;
	const transformedY = transform(xyz[1]);
	return [
		116 * transformedY - 16,
		500 * (transform(xyz[0] / .95047) - transformedY),
		200 * (transformedY - transform(xyz[2] / 1.08883))
	];
}
function toXYZ$1(lab) {
	const transform = cielabReverseTransform;
	const Ln = (lab[0] + 16) / 116;
	return [
		transform(Ln + lab[1] / 500) * .95047,
		transform(Ln),
		transform(Ln - lab[2] / 200) * 1.08883
	];
}

//#endregion
//#region node_modules/vuetify/lib/util/color/transformSRGB.js
const srgbForwardMatrix = [
	[
		3.2406,
		-1.5372,
		-.4986
	],
	[
		-.9689,
		1.8758,
		.0415
	],
	[
		.0557,
		-.204,
		1.057
	]
];
const srgbForwardTransform = (C) => C <= .0031308 ? C * 12.92 : 1.055 * C ** (1 / 2.4) - .055;
const srgbReverseMatrix = [
	[
		.4124,
		.3576,
		.1805
	],
	[
		.2126,
		.7152,
		.0722
	],
	[
		.0193,
		.1192,
		.9505
	]
];
const srgbReverseTransform = (C) => C <= .04045 ? C / 12.92 : ((C + .055) / 1.055) ** 2.4;
function fromXYZ(xyz) {
	const rgb = Array(3);
	const transform = srgbForwardTransform;
	const matrix = srgbForwardMatrix;
	for (let i = 0; i < 3; ++i) rgb[i] = Math.round(clamp(transform(matrix[i][0] * xyz[0] + matrix[i][1] * xyz[1] + matrix[i][2] * xyz[2])) * 255);
	return {
		r: rgb[0],
		g: rgb[1],
		b: rgb[2]
	};
}
function toXYZ(_ref) {
	let { r, g, b } = _ref;
	const xyz = [
		0,
		0,
		0
	];
	const transform = srgbReverseTransform;
	const matrix = srgbReverseMatrix;
	r = transform(r / 255);
	g = transform(g / 255);
	b = transform(b / 255);
	for (let i = 0; i < 3; ++i) xyz[i] = matrix[i][0] * r + matrix[i][1] * g + matrix[i][2] * b;
	return xyz;
}

//#endregion
//#region node_modules/vuetify/lib/util/colorUtils.js
function isCssColor(color) {
	return !!color && /^(#|var\(--|(rgb|hsl)a?\()/.test(color);
}
function isParsableColor(color) {
	return isCssColor(color) && !/^((rgb|hsl)a?\()?var\(--/.test(color);
}
const cssColorRe = /^(?<fn>(?:rgb|hsl)a?)\((?<values>.+)\)/;
const mappers = {
	rgb: (r, g, b, a) => ({
		r,
		g,
		b,
		a
	}),
	rgba: (r, g, b, a) => ({
		r,
		g,
		b,
		a
	}),
	hsl: (h, s, l, a) => HSLtoRGB({
		h,
		s,
		l,
		a
	}),
	hsla: (h, s, l, a) => HSLtoRGB({
		h,
		s,
		l,
		a
	}),
	hsv: (h, s, v, a) => HSVtoRGB({
		h,
		s,
		v,
		a
	}),
	hsva: (h, s, v, a) => HSVtoRGB({
		h,
		s,
		v,
		a
	})
};
function parseColor(color) {
	if (typeof color === "number") {
		if (isNaN(color) || color < 0 || color > 16777215) consoleWarn(`'${color}' is not a valid hex color`);
		return {
			r: (color & 16711680) >> 16,
			g: (color & 65280) >> 8,
			b: color & 255
		};
	} else if (typeof color === "string" && cssColorRe.test(color)) {
		const { groups } = color.match(cssColorRe);
		const { fn, values } = groups;
		const realValues = values.split(/,\s*|\s*\/\s*|\s+/).map((v, i) => {
			if (v.endsWith("%") || i > 0 && i < 3 && [
				"hsl",
				"hsla",
				"hsv",
				"hsva"
			].includes(fn)) return parseFloat(v) / 100;
			else return parseFloat(v);
		});
		return mappers[fn](...realValues);
	} else if (typeof color === "string") {
		let hex = color.startsWith("#") ? color.slice(1) : color;
		if ([3, 4].includes(hex.length)) hex = hex.split("").map((char) => char + char).join("");
		else if (![6, 8].includes(hex.length)) consoleWarn(`'${color}' is not a valid hex(a) color`);
		const int = parseInt(hex, 16);
		if (isNaN(int) || int < 0 || int > 4294967295) consoleWarn(`'${color}' is not a valid hex(a) color`);
		return HexToRGB(hex);
	} else if (typeof color === "object") {
		if (has(color, [
			"r",
			"g",
			"b"
		])) return color;
		else if (has(color, [
			"h",
			"s",
			"l"
		])) return HSVtoRGB(HSLtoHSV(color));
		else if (has(color, [
			"h",
			"s",
			"v"
		])) return HSVtoRGB(color);
	}
	throw new TypeError(`Invalid color: ${color == null ? color : String(color) || color.constructor.name}\nExpected #hex, #hexa, rgb(), rgba(), hsl(), hsla(), object or number`);
}
/** Converts HSVA to RGBA. Based on formula from https://en.wikipedia.org/wiki/HSL_and_HSV */
function HSVtoRGB(hsva) {
	const { h, s, v, a } = hsva;
	const f = (n) => {
		const k = (n + h / 60) % 6;
		return v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
	};
	const rgb = [
		f(5),
		f(3),
		f(1)
	].map((v$1) => Math.round(v$1 * 255));
	return {
		r: rgb[0],
		g: rgb[1],
		b: rgb[2],
		a
	};
}
function HSLtoRGB(hsla) {
	return HSVtoRGB(HSLtoHSV(hsla));
}
/** Converts RGBA to HSVA. Based on formula from https://en.wikipedia.org/wiki/HSL_and_HSV */
function RGBtoHSV(rgba) {
	if (!rgba) return {
		h: 0,
		s: 1,
		v: 1,
		a: 1
	};
	const r = rgba.r / 255;
	const g = rgba.g / 255;
	const b = rgba.b / 255;
	const max = Math.max(r, g, b);
	const min = Math.min(r, g, b);
	let h = 0;
	if (max !== min) {
		if (max === r) h = 60 * (0 + (g - b) / (max - min));
		else if (max === g) h = 60 * (2 + (b - r) / (max - min));
		else if (max === b) h = 60 * (4 + (r - g) / (max - min));
	}
	if (h < 0) h = h + 360;
	const s = max === 0 ? 0 : (max - min) / max;
	const hsv = [
		h,
		s,
		max
	];
	return {
		h: hsv[0],
		s: hsv[1],
		v: hsv[2],
		a: rgba.a
	};
}
function HSVtoHSL(hsva) {
	const { h, s, v, a } = hsva;
	const l = v - v * s / 2;
	const sprime = l === 1 || l === 0 ? 0 : (v - l) / Math.min(l, 1 - l);
	return {
		h,
		s: sprime,
		l,
		a
	};
}
function HSLtoHSV(hsl) {
	const { h, s, l, a } = hsl;
	const v = l + s * Math.min(l, 1 - l);
	const sprime = v === 0 ? 0 : 2 - 2 * l / v;
	return {
		h,
		s: sprime,
		v,
		a
	};
}
function RGBtoCSS(_ref) {
	let { r, g, b, a } = _ref;
	return a === void 0 ? `rgb(${r}, ${g}, ${b})` : `rgba(${r}, ${g}, ${b}, ${a})`;
}
function HSVtoCSS(hsva) {
	return RGBtoCSS(HSVtoRGB(hsva));
}
function toHex(v) {
	const h = Math.round(v).toString(16);
	return ("00".substr(0, 2 - h.length) + h).toUpperCase();
}
function RGBtoHex(_ref2) {
	let { r, g, b, a } = _ref2;
	return `#${[
		toHex(r),
		toHex(g),
		toHex(b),
		a !== void 0 ? toHex(Math.round(a * 255)) : ""
	].join("")}`;
}
function HexToRGB(hex) {
	hex = parseHex(hex);
	let [r, g, b, a] = chunk(hex, 2).map((c) => parseInt(c, 16));
	a = a === void 0 ? a : a / 255;
	return {
		r,
		g,
		b,
		a
	};
}
function HexToHSV(hex) {
	const rgb = HexToRGB(hex);
	return RGBtoHSV(rgb);
}
function HSVtoHex(hsva) {
	return RGBtoHex(HSVtoRGB(hsva));
}
function parseHex(hex) {
	if (hex.startsWith("#")) hex = hex.slice(1);
	hex = hex.replace(/([^0-9a-f])/gi, "F");
	if (hex.length === 3 || hex.length === 4) hex = hex.split("").map((x) => x + x).join("");
	if (hex.length !== 6) hex = padEnd(padEnd(hex, 6), 8, "F");
	return hex;
}
function lighten(value, amount) {
	const lab = fromXYZ$1(toXYZ(value));
	lab[0] = lab[0] + amount * 10;
	return fromXYZ(toXYZ$1(lab));
}
function darken(value, amount) {
	const lab = fromXYZ$1(toXYZ(value));
	lab[0] = lab[0] - amount * 10;
	return fromXYZ(toXYZ$1(lab));
}
/**
* Calculate the relative luminance of a given color
* @see https://www.w3.org/TR/WCAG20/#relativeluminancedef
*/
function getLuma(color) {
	const rgb = parseColor(color);
	return toXYZ(rgb)[1];
}
/**
* Returns the contrast ratio (1-21) between two colors.
* @see https://www.w3.org/TR/WCAG20/#contrast-ratiodef
*/
function getContrast(first, second) {
	const l1 = getLuma(first);
	const l2 = getLuma(second);
	const light = Math.max(l1, l2);
	const dark = Math.min(l1, l2);
	return (light + .05) / (dark + .05);
}
function getForeground(color) {
	const blackContrast = Math.abs(APCAcontrast(parseColor(0), parseColor(color)));
	const whiteContrast = Math.abs(APCAcontrast(parseColor(16777215), parseColor(color)));
	return whiteContrast > Math.min(blackContrast, 50) ? "#fff" : "#000";
}

//#endregion
//#region node_modules/vuetify/lib/composables/toggleScope.js
function useToggleScope(source, fn) {
	let scope;
	function start() {
		scope = effectScope();
		scope.run(() => fn.length ? fn(() => {
			scope?.stop();
			start();
		}) : fn());
	}
	watch(source, (active) => {
		if (active && !scope) start();
		else if (!active) {
			scope?.stop();
			scope = void 0;
		}
	}, { immediate: true });
	onScopeDispose(() => {
		scope?.stop();
	});
}

//#endregion
//#region node_modules/vuetify/lib/composables/proxiedModel.js
function useProxiedModel(props, prop, defaultValue) {
	let transformIn = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : (v) => v;
	let transformOut = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : (v) => v;
	const vm = getCurrentInstance("useProxiedModel");
	const internal = ref(props[prop] !== void 0 ? props[prop] : defaultValue);
	const kebabProp = toKebabCase(prop);
	const checkKebab = kebabProp !== prop;
	const isControlled = checkKebab ? computed(() => {
		props[prop];
		return !!((vm.vnode.props?.hasOwnProperty(prop) || vm.vnode.props?.hasOwnProperty(kebabProp)) && (vm.vnode.props?.hasOwnProperty(`onUpdate:${prop}`) || vm.vnode.props?.hasOwnProperty(`onUpdate:${kebabProp}`)));
	}) : computed(() => {
		props[prop];
		return !!(vm.vnode.props?.hasOwnProperty(prop) && vm.vnode.props?.hasOwnProperty(`onUpdate:${prop}`));
	});
	useToggleScope(() => !isControlled.value, () => {
		watch(() => props[prop], (val) => {
			internal.value = val;
		});
	});
	const model = computed({
		get() {
			const externalValue = props[prop];
			return transformIn(isControlled.value ? externalValue : internal.value);
		},
		set(internalValue) {
			const newValue = transformOut(internalValue);
			const value = toRaw(isControlled.value ? props[prop] : internal.value);
			if (value === newValue || transformIn(value) === internalValue) return;
			internal.value = newValue;
			vm?.emit(`update:${prop}`, newValue);
		}
	});
	Object.defineProperty(model, "externalValue", { get: () => isControlled.value ? props[prop] : internal.value });
	return model;
}

//#endregion
//#region node_modules/vuetify/lib/locale/en.js
var en_default = {
	badge: "Badge",
	open: "Open",
	close: "Close",
	dismiss: "Dismiss",
	confirmEdit: {
		ok: "OK",
		cancel: "Cancel"
	},
	dataIterator: {
		noResultsText: "No matching records found",
		loadingText: "Loading items..."
	},
	dataTable: {
		itemsPerPageText: "Rows per page:",
		ariaLabel: {
			sortDescending: "Sorted descending.",
			sortAscending: "Sorted ascending.",
			sortNone: "Not sorted.",
			activateNone: "Activate to remove sorting.",
			activateDescending: "Activate to sort descending.",
			activateAscending: "Activate to sort ascending."
		},
		sortBy: "Sort by"
	},
	dataFooter: {
		itemsPerPageText: "Items per page:",
		itemsPerPageAll: "All",
		nextPage: "Next page",
		prevPage: "Previous page",
		firstPage: "First page",
		lastPage: "Last page",
		pageText: "{0}-{1} of {2}"
	},
	dateRangeInput: { divider: "to" },
	datePicker: {
		itemsSelected: "{0} selected",
		range: {
			title: "Select dates",
			header: "Enter dates"
		},
		title: "Select date",
		header: "Enter date",
		input: { placeholder: "Enter date" }
	},
	noDataText: "No data available",
	carousel: {
		prev: "Previous visual",
		next: "Next visual",
		ariaLabel: { delimiter: "Carousel slide {0} of {1}" }
	},
	calendar: {
		moreEvents: "{0} more",
		today: "Today"
	},
	input: {
		clear: "Clear {0}",
		prependAction: "{0} prepended action",
		appendAction: "{0} appended action",
		otp: "Please enter OTP character {0}"
	},
	fileInput: {
		counter: "{0} files",
		counterSize: "{0} files ({1} in total)"
	},
	fileUpload: {
		title: "Drag and drop files here",
		divider: "or",
		browse: "Browse Files"
	},
	timePicker: {
		am: "AM",
		pm: "PM",
		title: "Select Time"
	},
	pagination: { ariaLabel: {
		root: "Pagination Navigation",
		next: "Next page",
		previous: "Previous page",
		page: "Go to page {0}",
		currentPage: "Page {0}, Current page",
		first: "First page",
		last: "Last page"
	} },
	stepper: {
		next: "Next",
		prev: "Previous"
	},
	rating: { ariaLabel: { item: "Rating {0} of {1}" } },
	loading: "Loading...",
	infiniteScroll: {
		loadMore: "Load more",
		empty: "No more"
	},
	rules: {
		required: "This field is required",
		email: "Please enter a valid email",
		number: "This field can only contain numbers",
		integer: "This field can only contain integer values",
		capital: "This field can only contain uppercase letters",
		maxLength: "You must enter a maximum of {0} characters",
		minLength: "You must enter a minimum of {0} characters",
		strictLength: "The length of the entered field is invalid",
		exclude: "The {0} character is not allowed",
		notEmpty: "Please choose at least one value",
		pattern: "Invalid format"
	},
	hotkey: {
		then: "then",
		ctrl: "Ctrl",
		command: "Command",
		space: "Space",
		shift: "Shift",
		alt: "Alt",
		enter: "Enter",
		escape: "Escape",
		upArrow: "Up Arrow",
		downArrow: "Down Arrow",
		leftArrow: "Left Arrow",
		rightArrow: "Right Arrow",
		backspace: "Backspace",
		option: "Option",
		plus: "plus",
		shortcut: "Keyboard shortcut: {0}"
	}
};

//#endregion
//#region node_modules/vuetify/lib/locale/adapters/vuetify.js
const LANG_PREFIX = "$vuetify.";
const replace = (str, params) => {
	return str.replace(/\{(\d+)\}/g, (match, index) => {
		return String(params[Number(index)]);
	});
};
const createTranslateFunction = (current, fallback, messages) => {
	return function(key) {
		for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) params[_key - 1] = arguments[_key];
		if (!key.startsWith(LANG_PREFIX)) return replace(key, params);
		const shortKey = key.replace(LANG_PREFIX, "");
		const currentLocale = current.value && messages.value[current.value];
		const fallbackLocale = fallback.value && messages.value[fallback.value];
		let str = getObjectValueByPath(currentLocale, shortKey, null);
		if (!str) {
			consoleWarn(`Translation key "${key}" not found in "${current.value}", trying fallback locale`);
			str = getObjectValueByPath(fallbackLocale, shortKey, null);
		}
		if (!str) {
			consoleError(`Translation key "${key}" not found in fallback`);
			str = key;
		}
		if (typeof str !== "string") {
			consoleError(`Translation key "${key}" has a non-string value`);
			str = key;
		}
		return replace(str, params);
	};
};
function createNumberFunction(current, fallback) {
	return (value, options) => {
		const numberFormat = new Intl.NumberFormat([current.value, fallback.value], options);
		return numberFormat.format(value);
	};
}
function inferDecimalSeparator(current, fallback) {
	const format = createNumberFunction(current, fallback);
	return format(.1).includes(",") ? "," : ".";
}
function useProvided(props, prop, provided) {
	const internal = useProxiedModel(props, prop, props[prop] ?? provided.value);
	internal.value = props[prop] ?? provided.value;
	watch(provided, (v) => {
		if (props[prop] == null) internal.value = provided.value;
	});
	return internal;
}
function createProvideFunction(state) {
	return (props) => {
		const current = useProvided(props, "locale", state.current);
		const fallback = useProvided(props, "fallback", state.fallback);
		const messages = useProvided(props, "messages", state.messages);
		return {
			name: "vuetify",
			current,
			fallback,
			messages,
			decimalSeparator: toRef(() => inferDecimalSeparator(current, fallback)),
			t: createTranslateFunction(current, fallback, messages),
			n: createNumberFunction(current, fallback),
			provide: createProvideFunction({
				current,
				fallback,
				messages
			})
		};
	};
}
function createVuetifyAdapter(options) {
	const current = shallowRef(options?.locale ?? "en");
	const fallback = shallowRef(options?.fallback ?? "en");
	const messages = ref({
		en: en_default,
		...options?.messages
	});
	return {
		name: "vuetify",
		current,
		fallback,
		messages,
		decimalSeparator: toRef(() => options?.decimalSeparator ?? inferDecimalSeparator(current, fallback)),
		t: createTranslateFunction(current, fallback, messages),
		n: createNumberFunction(current, fallback),
		provide: createProvideFunction({
			current,
			fallback,
			messages
		})
	};
}

//#endregion
//#region node_modules/vuetify/lib/composables/locale.js
const LocaleSymbol = Symbol.for("vuetify:locale");
function isLocaleInstance(obj) {
	return obj.name != null;
}
function createLocale(options) {
	const i18n = options?.adapter && isLocaleInstance(options?.adapter) ? options?.adapter : createVuetifyAdapter(options);
	const rtl = createRtl(i18n, options);
	return {
		...i18n,
		...rtl
	};
}
function useLocale() {
	const locale = inject(LocaleSymbol);
	if (!locale) throw new Error("[Vuetify] Could not find injected locale instance");
	return locale;
}
function provideLocale(props) {
	const locale = inject(LocaleSymbol);
	if (!locale) throw new Error("[Vuetify] Could not find injected locale instance");
	const i18n = locale.provide(props);
	const rtl = provideRtl(i18n, locale.rtl, props);
	const data = {
		...i18n,
		...rtl
	};
	provide(LocaleSymbol, data);
	return data;
}
const RtlSymbol = Symbol.for("vuetify:rtl");
function genDefaults$1() {
	return {
		af: false,
		ar: true,
		bg: false,
		ca: false,
		ckb: false,
		cs: false,
		de: false,
		el: false,
		en: false,
		es: false,
		et: false,
		fa: true,
		fi: false,
		fr: false,
		hr: false,
		hu: false,
		he: true,
		id: false,
		it: false,
		ja: false,
		km: false,
		ko: false,
		lv: false,
		lt: false,
		nl: false,
		no: false,
		pl: false,
		pt: false,
		ro: false,
		ru: false,
		sk: false,
		sl: false,
		srCyrl: false,
		srLatn: false,
		sv: false,
		th: false,
		tr: false,
		az: false,
		uk: false,
		vi: false,
		zhHans: false,
		zhHant: false
	};
}
function createRtl(i18n, options) {
	const rtl = ref(options?.rtl ?? genDefaults$1());
	const isRtl = computed(() => rtl.value[i18n.current.value] ?? false);
	return {
		isRtl,
		rtl,
		rtlClasses: toRef(() => `v-locale--is-${isRtl.value ? "rtl" : "ltr"}`)
	};
}
function provideRtl(locale, rtl, props) {
	const isRtl = computed(() => props.rtl ?? rtl.value[locale.current.value] ?? false);
	return {
		isRtl,
		rtl,
		rtlClasses: toRef(() => `v-locale--is-${isRtl.value ? "rtl" : "ltr"}`)
	};
}
function useRtl() {
	const locale = inject(LocaleSymbol);
	if (!locale) throw new Error("[Vuetify] Could not find injected rtl instance");
	return {
		isRtl: locale.isRtl,
		rtlClasses: locale.rtlClasses
	};
}

//#endregion
//#region node_modules/vuetify/lib/composables/display.js
const breakpoints = [
	"sm",
	"md",
	"lg",
	"xl",
	"xxl"
];
const DisplaySymbol = Symbol.for("vuetify:display");
const defaultDisplayOptions = {
	mobileBreakpoint: "lg",
	thresholds: {
		xs: 0,
		sm: 600,
		md: 960,
		lg: 1280,
		xl: 1920,
		xxl: 2560
	}
};
const parseDisplayOptions = function() {
	let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultDisplayOptions;
	return mergeDeep(defaultDisplayOptions, options);
};
function getClientWidth(ssr) {
	return IN_BROWSER && !ssr ? window.innerWidth : typeof ssr === "object" && ssr.clientWidth || 0;
}
function getClientHeight(ssr) {
	return IN_BROWSER && !ssr ? window.innerHeight : typeof ssr === "object" && ssr.clientHeight || 0;
}
function getPlatform(ssr) {
	const userAgent = IN_BROWSER && !ssr ? window.navigator.userAgent : "ssr";
	function match(regexp) {
		return Boolean(userAgent.match(regexp));
	}
	const android = match(/android/i);
	const ios = match(/iphone|ipad|ipod/i);
	const cordova = match(/cordova/i);
	const electron = match(/electron/i);
	const chrome = match(/chrome/i);
	const edge = match(/edge/i);
	const firefox = match(/firefox/i);
	const opera = match(/opera/i);
	const win = match(/win/i);
	const mac = match(/mac/i);
	const linux = match(/linux/i);
	return {
		android,
		ios,
		cordova,
		electron,
		chrome,
		edge,
		firefox,
		opera,
		win,
		mac,
		linux,
		touch: SUPPORTS_TOUCH,
		ssr: userAgent === "ssr"
	};
}
function createDisplay(options, ssr) {
	const { thresholds, mobileBreakpoint } = parseDisplayOptions(options);
	const height = shallowRef(getClientHeight(ssr));
	const platform = shallowRef(getPlatform(ssr));
	const state = reactive({});
	const width = shallowRef(getClientWidth(ssr));
	function updateSize() {
		height.value = getClientHeight();
		width.value = getClientWidth();
	}
	function update() {
		updateSize();
		platform.value = getPlatform();
	}
	watchEffect(() => {
		const xs = width.value < thresholds.sm;
		const sm = width.value < thresholds.md && !xs;
		const md = width.value < thresholds.lg && !(sm || xs);
		const lg = width.value < thresholds.xl && !(md || sm || xs);
		const xl = width.value < thresholds.xxl && !(lg || md || sm || xs);
		const xxl = width.value >= thresholds.xxl;
		const name = xs ? "xs" : sm ? "sm" : md ? "md" : lg ? "lg" : xl ? "xl" : "xxl";
		const breakpointValue = typeof mobileBreakpoint === "number" ? mobileBreakpoint : thresholds[mobileBreakpoint];
		const mobile = width.value < breakpointValue;
		state.xs = xs;
		state.sm = sm;
		state.md = md;
		state.lg = lg;
		state.xl = xl;
		state.xxl = xxl;
		state.smAndUp = !xs;
		state.mdAndUp = !(xs || sm);
		state.lgAndUp = !(xs || sm || md);
		state.xlAndUp = !(xs || sm || md || lg);
		state.smAndDown = !(md || lg || xl || xxl);
		state.mdAndDown = !(lg || xl || xxl);
		state.lgAndDown = !(xl || xxl);
		state.xlAndDown = !xxl;
		state.name = name;
		state.height = height.value;
		state.width = width.value;
		state.mobile = mobile;
		state.mobileBreakpoint = mobileBreakpoint;
		state.platform = platform.value;
		state.thresholds = thresholds;
	});
	if (IN_BROWSER) {
		window.addEventListener("resize", updateSize, { passive: true });
		onScopeDispose(() => {
			window.removeEventListener("resize", updateSize);
		}, true);
	}
	return {
		...toRefs(state),
		update,
		ssr: !!ssr
	};
}
const makeDisplayProps = propsFactory({
	mobile: {
		type: Boolean,
		default: false
	},
	mobileBreakpoint: [Number, String]
}, "display");
function useDisplay() {
	let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { mobile: null };
	let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
	const display = inject(DisplaySymbol);
	if (!display) throw new Error("Could not find Vuetify display injection");
	const mobile = computed(() => {
		if (props.mobile) return true;
		else if (typeof props.mobileBreakpoint === "number") return display.width.value < props.mobileBreakpoint;
		else if (props.mobileBreakpoint) return display.width.value < display.thresholds.value[props.mobileBreakpoint];
		else if (props.mobile === null) return display.mobile.value;
		else return false;
	});
	const displayClasses = toRef(() => {
		if (!name) return {};
		return { [`${name}--mobile`]: mobile.value };
	});
	return {
		...display,
		displayClasses,
		mobile
	};
}

//#endregion
//#region node_modules/vuetify/lib/composables/theme.js
const ThemeSymbol = Symbol.for("vuetify:theme");
const makeThemeProps = propsFactory({ theme: String }, "theme");
function genDefaults() {
	return {
		defaultTheme: "light",
		prefix: "v-",
		variations: {
			colors: [],
			lighten: 0,
			darken: 0
		},
		themes: {
			light: {
				dark: false,
				colors: {
					background: "#FFFFFF",
					surface: "#FFFFFF",
					"surface-bright": "#FFFFFF",
					"surface-light": "#EEEEEE",
					"surface-variant": "#424242",
					"on-surface-variant": "#EEEEEE",
					primary: "#1867C0",
					"primary-darken-1": "#1F5592",
					secondary: "#48A9A6",
					"secondary-darken-1": "#018786",
					error: "#B00020",
					info: "#2196F3",
					success: "#4CAF50",
					warning: "#FB8C00"
				},
				variables: {
					"border-color": "#000000",
					"border-opacity": .12,
					"high-emphasis-opacity": .87,
					"medium-emphasis-opacity": .6,
					"disabled-opacity": .38,
					"idle-opacity": .04,
					"hover-opacity": .04,
					"focus-opacity": .12,
					"selected-opacity": .08,
					"activated-opacity": .12,
					"pressed-opacity": .12,
					"dragged-opacity": .08,
					"theme-kbd": "#EEEEEE",
					"theme-on-kbd": "#000000",
					"theme-code": "#F5F5F5",
					"theme-on-code": "#000000"
				}
			},
			dark: {
				dark: true,
				colors: {
					background: "#121212",
					surface: "#212121",
					"surface-bright": "#ccbfd6",
					"surface-light": "#424242",
					"surface-variant": "#c8c8c8",
					"on-surface-variant": "#000000",
					primary: "#2196F3",
					"primary-darken-1": "#277CC1",
					secondary: "#54B6B2",
					"secondary-darken-1": "#48A9A6",
					error: "#CF6679",
					info: "#2196F3",
					success: "#4CAF50",
					warning: "#FB8C00"
				},
				variables: {
					"border-color": "#FFFFFF",
					"border-opacity": .12,
					"high-emphasis-opacity": 1,
					"medium-emphasis-opacity": .7,
					"disabled-opacity": .5,
					"idle-opacity": .1,
					"hover-opacity": .04,
					"focus-opacity": .12,
					"selected-opacity": .08,
					"activated-opacity": .12,
					"pressed-opacity": .16,
					"dragged-opacity": .08,
					"theme-kbd": "#424242",
					"theme-on-kbd": "#FFFFFF",
					"theme-code": "#343434",
					"theme-on-code": "#CCCCCC"
				}
			}
		},
		stylesheetId: "vuetify-theme-stylesheet",
		scoped: false,
		unimportant: false,
		utilities: true
	};
}
function parseThemeOptions() {
	let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : genDefaults();
	const defaults = genDefaults();
	if (!options) return {
		...defaults,
		isDisabled: true
	};
	const themes = {};
	for (const [key, theme] of Object.entries(options.themes ?? {})) {
		const defaultTheme = theme.dark || key === "dark" ? defaults.themes?.dark : defaults.themes?.light;
		themes[key] = mergeDeep(defaultTheme, theme);
	}
	return mergeDeep(defaults, {
		...options,
		themes
	});
}
function createCssClass(lines, selector, content, scope) {
	lines.push(`${getScopedSelector(selector, scope)} {\n`, ...content.map((line) => `  ${line};\n`), "}\n");
}
function genCssVariables(theme, prefix) {
	const lightOverlay = theme.dark ? 2 : 1;
	const darkOverlay = theme.dark ? 1 : 2;
	const variables = [];
	for (const [key, value] of Object.entries(theme.colors)) {
		const rgb = parseColor(value);
		variables.push(`--${prefix}theme-${key}: ${rgb.r},${rgb.g},${rgb.b}`);
		if (!key.startsWith("on-")) variables.push(`--${prefix}theme-${key}-overlay-multiplier: ${getLuma(value) > .18 ? lightOverlay : darkOverlay}`);
	}
	for (const [key, value] of Object.entries(theme.variables)) {
		const color = typeof value === "string" && value.startsWith("#") ? parseColor(value) : void 0;
		const rgb = color ? `${color.r}, ${color.g}, ${color.b}` : void 0;
		variables.push(`--${prefix}${key}: ${rgb ?? value}`);
	}
	return variables;
}
function genVariation(name, color, variations) {
	const object = {};
	if (variations) for (const variation of ["lighten", "darken"]) {
		const fn = variation === "lighten" ? lighten : darken;
		for (const amount of createRange(variations[variation], 1)) object[`${name}-${variation}-${amount}`] = RGBtoHex(fn(parseColor(color), amount));
	}
	return object;
}
function genVariations(colors, variations) {
	if (!variations) return {};
	let variationColors = {};
	for (const name of variations.colors) {
		const color = colors[name];
		if (!color) continue;
		variationColors = {
			...variationColors,
			...genVariation(name, color, variations)
		};
	}
	return variationColors;
}
function genOnColors(colors) {
	const onColors = {};
	for (const color of Object.keys(colors)) {
		if (color.startsWith("on-") || colors[`on-${color}`]) continue;
		const onColor = `on-${color}`;
		const colorVal = parseColor(colors[color]);
		onColors[onColor] = getForeground(colorVal);
	}
	return onColors;
}
function getScopedSelector(selector, scope) {
	if (!scope) return selector;
	const scopeSelector = `:where(${scope})`;
	return selector === ":root" ? scopeSelector : `${scopeSelector} ${selector}`;
}
function upsertStyles(id, cspNonce, styles) {
	const styleEl = getOrCreateStyleElement(id, cspNonce);
	if (!styleEl) return;
	styleEl.innerHTML = styles;
}
function getOrCreateStyleElement(id, cspNonce) {
	if (!IN_BROWSER) return null;
	let style = document.getElementById(id);
	if (!style) {
		style = document.createElement("style");
		style.id = id;
		style.type = "text/css";
		if (cspNonce) style.setAttribute("nonce", cspNonce);
		document.head.appendChild(style);
	}
	return style;
}
function createTheme(options) {
	const parsedOptions = parseThemeOptions(options);
	const _name = shallowRef(parsedOptions.defaultTheme);
	const themes = ref(parsedOptions.themes);
	const systemName = shallowRef("light");
	const name = computed({
		get() {
			return _name.value === "system" ? systemName.value : _name.value;
		},
		set(val) {
			_name.value = val;
		}
	});
	const computedThemes = computed(() => {
		const acc = {};
		for (const [name$1, original] of Object.entries(themes.value)) {
			const colors = {
				...original.colors,
				...genVariations(original.colors, parsedOptions.variations)
			};
			acc[name$1] = {
				...original,
				colors: {
					...colors,
					...genOnColors(colors)
				}
			};
		}
		return acc;
	});
	const current = toRef(() => computedThemes.value[name.value]);
	const styles = computed(() => {
		const lines = [];
		const important = parsedOptions.unimportant ? "" : " !important";
		const scoped = parsedOptions.scoped ? parsedOptions.prefix : "";
		if (current.value?.dark) createCssClass(lines, ":root", ["color-scheme: dark"], parsedOptions.scope);
		createCssClass(lines, ":root", genCssVariables(current.value, parsedOptions.prefix), parsedOptions.scope);
		for (const [themeName, theme] of Object.entries(computedThemes.value)) createCssClass(lines, `.${parsedOptions.prefix}theme--${themeName}`, [`color-scheme: ${theme.dark ? "dark" : "normal"}`, ...genCssVariables(theme, parsedOptions.prefix)], parsedOptions.scope);
		if (parsedOptions.utilities) {
			const bgLines = [];
			const fgLines = [];
			const colors = new Set(Object.values(computedThemes.value).flatMap((theme) => Object.keys(theme.colors)));
			for (const key of colors) if (key.startsWith("on-")) createCssClass(fgLines, `.${key}`, [`color: rgb(var(--${parsedOptions.prefix}theme-${key}))${important}`], parsedOptions.scope);
			else {
				createCssClass(bgLines, `.${scoped}bg-${key}`, [
					`--${parsedOptions.prefix}theme-overlay-multiplier: var(--${parsedOptions.prefix}theme-${key}-overlay-multiplier)`,
					`background-color: rgb(var(--${parsedOptions.prefix}theme-${key}))${important}`,
					`color: rgb(var(--${parsedOptions.prefix}theme-on-${key}))${important}`
				], parsedOptions.scope);
				createCssClass(fgLines, `.${scoped}text-${key}`, [`color: rgb(var(--${parsedOptions.prefix}theme-${key}))${important}`], parsedOptions.scope);
				createCssClass(fgLines, `.${scoped}border-${key}`, [`--${parsedOptions.prefix}border-color: var(--${parsedOptions.prefix}theme-${key})`], parsedOptions.scope);
			}
			lines.push(...bgLines, ...fgLines);
		}
		return lines.map((str, i) => i === 0 ? str : `    ${str}`).join("");
	});
	const themeClasses = toRef(() => parsedOptions.isDisabled ? void 0 : `${parsedOptions.prefix}theme--${name.value}`);
	const themeNames = toRef(() => Object.keys(computedThemes.value));
	if (SUPPORTS_MATCH_MEDIA) {
		const media = window.matchMedia("(prefers-color-scheme: dark)");
		function updateSystemName() {
			systemName.value = media.matches ? "dark" : "light";
		}
		updateSystemName();
		media.addEventListener("change", updateSystemName, { passive: true });
		if (getCurrentScope()) onScopeDispose(() => {
			media.removeEventListener("change", updateSystemName);
		});
	}
	function install(app) {
		if (parsedOptions.isDisabled) return;
		const head = app._context.provides.usehead;
		if (head) {
			function getHead() {
				return { style: [{
					textContent: styles.value,
					id: parsedOptions.stylesheetId,
					nonce: parsedOptions.cspNonce || false
				}] };
			}
			if (head.push) {
				const entry = head.push(getHead);
				if (IN_BROWSER) watch(styles, () => {
					entry.patch(getHead);
				});
			} else if (IN_BROWSER) {
				head.addHeadObjs(toRef(getHead));
				watchEffect(() => head.updateDOM());
			} else head.addHeadObjs(getHead());
		} else {
			if (IN_BROWSER) watch(styles, updateStyles, { immediate: true });
			else updateStyles();
			function updateStyles() {
				upsertStyles(parsedOptions.stylesheetId, parsedOptions.cspNonce, styles.value);
			}
		}
	}
	function change(themeName) {
		if (!themeNames.value.includes(themeName)) {
			consoleWarn(`Theme "${themeName}" not found on the Vuetify theme instance`);
			return;
		}
		name.value = themeName;
	}
	function cycle() {
		let themeArray = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : themeNames.value;
		const currentIndex = themeArray.indexOf(name.value);
		const nextIndex = currentIndex === -1 ? 0 : (currentIndex + 1) % themeArray.length;
		change(themeArray[nextIndex]);
	}
	function toggle() {
		let themeArray = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ["light", "dark"];
		cycle(themeArray);
	}
	const globalName = new Proxy(name, {
		get(target, prop) {
			return Reflect.get(target, prop);
		},
		set(target, prop, val) {
			if (prop === "value") deprecate(`theme.global.name.value = ${val}`, `theme.change('${val}')`);
			return Reflect.set(target, prop, val);
		}
	});
	return {
		install,
		change,
		cycle,
		toggle,
		isDisabled: parsedOptions.isDisabled,
		name,
		themes,
		current,
		computedThemes,
		prefix: parsedOptions.prefix,
		themeClasses,
		styles,
		global: {
			name: globalName,
			current
		}
	};
}
function provideTheme(props) {
	getCurrentInstance("provideTheme");
	const theme = inject(ThemeSymbol, null);
	if (!theme) throw new Error("Could not find Vuetify theme injection");
	const name = toRef(() => props.theme ?? theme.name.value);
	const current = toRef(() => theme.themes.value[name.value]);
	const themeClasses = toRef(() => theme.isDisabled ? void 0 : `${theme.prefix}theme--${name.value}`);
	const newTheme = {
		...theme,
		name,
		current,
		themeClasses
	};
	provide(ThemeSymbol, newTheme);
	return newTheme;
}
function useTheme() {
	getCurrentInstance("useTheme");
	const theme = inject(ThemeSymbol, null);
	if (!theme) throw new Error("Could not find Vuetify theme injection");
	return theme;
}

//#endregion
export { DisplaySymbol, HSLtoHSV, HSVtoCSS, HSVtoHSL, HSVtoHex, HSVtoRGB, HexToHSV, LocaleSymbol, RGBtoCSS, RGBtoHSV, ThemeSymbol, breakpoints, createDisplay, createLocale, createTheme, getContrast, getForeground, isCssColor, isParsableColor, makeDisplayProps, makeThemeProps, parseColor, provideLocale, provideTheme, useDisplay, useLocale, useProxiedModel, useRtl, useTheme, useToggleScope };
//# sourceMappingURL=theme-8uHrIPrN.js.map