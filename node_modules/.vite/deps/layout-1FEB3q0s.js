import { computed, inject, onActivated, onBeforeUnmount, onDeactivated, onMounted, provide, reactive, readonly, ref, shallowRef, toRef, useId, watch } from "./vue.runtime.esm-bundler-CvPjzdzA.js";
import { IN_BROWSER, clamp, consoleWarn, convertToUnit, createRange, findChildrenWithProvide, getCurrentInstance, mergeDeep, padStart, propsFactory, refElement, templateRef } from "./defineComponent-CAKzfwnn.js";
import { useLocale, useRtl } from "./theme-8uHrIPrN.js";

//#region node_modules/vuetify/lib/composables/date/adapters/vuetify.js
function weekInfo(locale) {
	const code = locale.slice(-2).toUpperCase();
	switch (true) {
		case locale === "GB-alt-variant": return {
			firstDay: 0,
			firstWeekSize: 4
		};
		case locale === "001": return {
			firstDay: 1,
			firstWeekSize: 1
		};
		case `AG AS BD BR BS BT BW BZ CA CO DM DO ET GT GU HK HN ID IL IN JM JP KE
    KH KR LA MH MM MO MT MX MZ NI NP PA PE PH PK PR PY SA SG SV TH TT TW UM US
    VE VI WS YE ZA ZW`.includes(code): return {
			firstDay: 0,
			firstWeekSize: 1
		};
		case `AI AL AM AR AU AZ BA BM BN BY CL CM CN CR CY EC GE HR KG KZ LB LK LV
    MD ME MK MN MY NZ RO RS SI TJ TM TR UA UY UZ VN XK`.includes(code): return {
			firstDay: 1,
			firstWeekSize: 1
		};
		case `AD AN AT AX BE BG CH CZ DE DK EE ES FI FJ FO FR GB GF GP GR HU IE IS
    IT LI LT LU MC MQ NL NO PL RE RU SE SK SM VA`.includes(code): return {
			firstDay: 1,
			firstWeekSize: 4
		};
		case `AE AF BH DJ DZ EG IQ IR JO KW LY OM QA SD SY`.includes(code): return {
			firstDay: 6,
			firstWeekSize: 1
		};
		case code === "MV": return {
			firstDay: 5,
			firstWeekSize: 1
		};
		case code === "PT": return {
			firstDay: 0,
			firstWeekSize: 4
		};
		default: return null;
	}
}
function getWeekArray(date$1, locale, firstDayOfWeek) {
	const weeks = [];
	let currentWeek = [];
	const firstDayOfMonth = startOfMonth(date$1);
	const lastDayOfMonth = endOfMonth(date$1);
	const first = firstDayOfWeek ?? weekInfo(locale)?.firstDay ?? 0;
	const firstDayWeekIndex = (firstDayOfMonth.getDay() - first + 7) % 7;
	const lastDayWeekIndex = (lastDayOfMonth.getDay() - first + 7) % 7;
	for (let i = 0; i < firstDayWeekIndex; i++) {
		const adjacentDay = new Date(firstDayOfMonth);
		adjacentDay.setDate(adjacentDay.getDate() - (firstDayWeekIndex - i));
		currentWeek.push(adjacentDay);
	}
	for (let i = 1; i <= lastDayOfMonth.getDate(); i++) {
		const day = new Date(date$1.getFullYear(), date$1.getMonth(), i);
		currentWeek.push(day);
		if (currentWeek.length === 7) {
			weeks.push(currentWeek);
			currentWeek = [];
		}
	}
	for (let i = 1; i < 7 - lastDayWeekIndex; i++) {
		const adjacentDay = new Date(lastDayOfMonth);
		adjacentDay.setDate(adjacentDay.getDate() + i);
		currentWeek.push(adjacentDay);
	}
	if (currentWeek.length > 0) weeks.push(currentWeek);
	return weeks;
}
function startOfWeek(date$1, locale, firstDayOfWeek) {
	const day = firstDayOfWeek ?? weekInfo(locale)?.firstDay ?? 0;
	const d = new Date(date$1);
	while (d.getDay() !== day) d.setDate(d.getDate() - 1);
	return d;
}
function endOfWeek(date$1, locale) {
	const d = new Date(date$1);
	const lastDay = ((weekInfo(locale)?.firstDay ?? 0) + 6) % 7;
	while (d.getDay() !== lastDay) d.setDate(d.getDate() + 1);
	return d;
}
function startOfMonth(date$1) {
	return new Date(date$1.getFullYear(), date$1.getMonth(), 1);
}
function endOfMonth(date$1) {
	return new Date(date$1.getFullYear(), date$1.getMonth() + 1, 0);
}
function parseLocalDate(value) {
	const parts = value.split("-").map(Number);
	return new Date(parts[0], parts[1] - 1, parts[2]);
}
const _YYYMMDD = /^([12]\d{3}-([1-9]|0[1-9]|1[0-2])-([1-9]|0[1-9]|[12]\d|3[01]))$/;
function date(value) {
	if (value == null) return /* @__PURE__ */ new Date();
	if (value instanceof Date) return value;
	if (typeof value === "string") {
		let parsed;
		if (_YYYMMDD.test(value)) return parseLocalDate(value);
		else parsed = Date.parse(value);
		if (!isNaN(parsed)) return new Date(parsed);
	}
	return null;
}
const sundayJanuarySecond2000 = new Date(2e3, 0, 2);
function getWeekdays(locale, firstDayOfWeek, weekdayFormat) {
	const daysFromSunday = firstDayOfWeek ?? weekInfo(locale)?.firstDay ?? 0;
	return createRange(7).map((i) => {
		const weekday = new Date(sundayJanuarySecond2000);
		weekday.setDate(sundayJanuarySecond2000.getDate() + daysFromSunday + i);
		return new Intl.DateTimeFormat(locale, { weekday: weekdayFormat ?? "narrow" }).format(weekday);
	});
}
function format(value, formatString, locale, formats) {
	const newDate = date(value) ?? /* @__PURE__ */ new Date();
	const customFormat = formats?.[formatString];
	if (typeof customFormat === "function") return customFormat(newDate, formatString, locale);
	let options = {};
	switch (formatString) {
		case "fullDate":
			options = {
				year: "numeric",
				month: "short",
				day: "numeric"
			};
			break;
		case "fullDateWithWeekday":
			options = {
				weekday: "long",
				year: "numeric",
				month: "long",
				day: "numeric"
			};
			break;
		case "normalDate":
			const day = newDate.getDate();
			const month = new Intl.DateTimeFormat(locale, { month: "long" }).format(newDate);
			return `${day} ${month}`;
		case "normalDateWithWeekday":
			options = {
				weekday: "short",
				day: "numeric",
				month: "short"
			};
			break;
		case "shortDate":
			options = {
				month: "short",
				day: "numeric"
			};
			break;
		case "year":
			options = { year: "numeric" };
			break;
		case "month":
			options = { month: "long" };
			break;
		case "monthShort":
			options = { month: "short" };
			break;
		case "monthAndYear":
			options = {
				month: "long",
				year: "numeric"
			};
			break;
		case "monthAndDate":
			options = {
				month: "long",
				day: "numeric"
			};
			break;
		case "weekday":
			options = { weekday: "long" };
			break;
		case "weekdayShort":
			options = { weekday: "short" };
			break;
		case "dayOfMonth": return new Intl.NumberFormat(locale).format(newDate.getDate());
		case "hours12h":
			options = {
				hour: "numeric",
				hour12: true
			};
			break;
		case "hours24h":
			options = {
				hour: "numeric",
				hour12: false
			};
			break;
		case "minutes":
			options = { minute: "numeric" };
			break;
		case "seconds":
			options = { second: "numeric" };
			break;
		case "fullTime":
			options = {
				hour: "numeric",
				minute: "numeric"
			};
			break;
		case "fullTime12h":
			options = {
				hour: "numeric",
				minute: "numeric",
				hour12: true
			};
			break;
		case "fullTime24h":
			options = {
				hour: "numeric",
				minute: "numeric",
				hour12: false
			};
			break;
		case "fullDateTime":
			options = {
				year: "numeric",
				month: "short",
				day: "numeric",
				hour: "numeric",
				minute: "numeric"
			};
			break;
		case "fullDateTime12h":
			options = {
				year: "numeric",
				month: "short",
				day: "numeric",
				hour: "numeric",
				minute: "numeric",
				hour12: true
			};
			break;
		case "fullDateTime24h":
			options = {
				year: "numeric",
				month: "short",
				day: "numeric",
				hour: "numeric",
				minute: "numeric",
				hour12: false
			};
			break;
		case "keyboardDate":
			options = {
				year: "numeric",
				month: "2-digit",
				day: "2-digit"
			};
			break;
		case "keyboardDateTime":
			options = {
				year: "numeric",
				month: "2-digit",
				day: "2-digit",
				hour: "numeric",
				minute: "numeric"
			};
			return new Intl.DateTimeFormat(locale, options).format(newDate).replace(/, /g, " ");
		case "keyboardDateTime12h":
			options = {
				year: "numeric",
				month: "2-digit",
				day: "2-digit",
				hour: "numeric",
				minute: "numeric",
				hour12: true
			};
			return new Intl.DateTimeFormat(locale, options).format(newDate).replace(/, /g, " ");
		case "keyboardDateTime24h":
			options = {
				year: "numeric",
				month: "2-digit",
				day: "2-digit",
				hour: "numeric",
				minute: "numeric",
				hour12: false
			};
			return new Intl.DateTimeFormat(locale, options).format(newDate).replace(/, /g, " ");
		default: options = customFormat ?? {
			timeZone: "UTC",
			timeZoneName: "short"
		};
	}
	return new Intl.DateTimeFormat(locale, options).format(newDate);
}
function toISO(adapter, value) {
	const date$1 = adapter.toJsDate(value);
	const year = date$1.getFullYear();
	const month = padStart(String(date$1.getMonth() + 1), 2, "0");
	const day = padStart(String(date$1.getDate()), 2, "0");
	return `${year}-${month}-${day}`;
}
function parseISO(value) {
	const [year, month, day] = value.split("-").map(Number);
	return new Date(year, month - 1, day);
}
function addMinutes(date$1, amount) {
	const d = new Date(date$1);
	d.setMinutes(d.getMinutes() + amount);
	return d;
}
function addHours(date$1, amount) {
	const d = new Date(date$1);
	d.setHours(d.getHours() + amount);
	return d;
}
function addDays(date$1, amount) {
	const d = new Date(date$1);
	d.setDate(d.getDate() + amount);
	return d;
}
function addWeeks(date$1, amount) {
	const d = new Date(date$1);
	d.setDate(d.getDate() + amount * 7);
	return d;
}
function addMonths(date$1, amount) {
	const d = new Date(date$1);
	d.setDate(1);
	d.setMonth(d.getMonth() + amount);
	return d;
}
function getYear(date$1) {
	return date$1.getFullYear();
}
function getMonth(date$1) {
	return date$1.getMonth();
}
function getWeek(date$1, locale, firstDayOfWeek, firstWeekMinSize) {
	const weekInfoFromLocale = weekInfo(locale);
	const weekStart = firstDayOfWeek ?? weekInfoFromLocale?.firstDay ?? 0;
	const minWeekSize = firstWeekMinSize ?? weekInfoFromLocale?.firstWeekSize ?? 1;
	function firstWeekSize(year$1) {
		const yearStart$1 = new Date(year$1, 0, 1);
		return 7 - getDiff(yearStart$1, startOfWeek(yearStart$1, locale, weekStart), "days");
	}
	let year = getYear(date$1);
	const currentWeekEnd = addDays(startOfWeek(date$1, locale, weekStart), 6);
	if (year < getYear(currentWeekEnd) && firstWeekSize(year + 1) >= minWeekSize) year++;
	const yearStart = new Date(year, 0, 1);
	const size = firstWeekSize(year);
	const d1w1 = size >= minWeekSize ? addDays(yearStart, size - 7) : addDays(yearStart, size);
	return 1 + getDiff(endOfDay(date$1), startOfDay(d1w1), "weeks");
}
function getDate(date$1) {
	return date$1.getDate();
}
function getNextMonth(date$1) {
	return new Date(date$1.getFullYear(), date$1.getMonth() + 1, 1);
}
function getPreviousMonth(date$1) {
	return new Date(date$1.getFullYear(), date$1.getMonth() - 1, 1);
}
function getHours(date$1) {
	return date$1.getHours();
}
function getMinutes(date$1) {
	return date$1.getMinutes();
}
function startOfYear(date$1) {
	return new Date(date$1.getFullYear(), 0, 1);
}
function endOfYear(date$1) {
	return new Date(date$1.getFullYear(), 11, 31);
}
function isWithinRange(date$1, range) {
	return isAfter(date$1, range[0]) && isBefore(date$1, range[1]);
}
function isValid(date$1) {
	const d = new Date(date$1);
	return d instanceof Date && !isNaN(d.getTime());
}
function isAfter(date$1, comparing) {
	return date$1.getTime() > comparing.getTime();
}
function isAfterDay(date$1, comparing) {
	return isAfter(startOfDay(date$1), startOfDay(comparing));
}
function isBefore(date$1, comparing) {
	return date$1.getTime() < comparing.getTime();
}
function isEqual(date$1, comparing) {
	return date$1.getTime() === comparing.getTime();
}
function isSameDay(date$1, comparing) {
	return date$1.getDate() === comparing.getDate() && date$1.getMonth() === comparing.getMonth() && date$1.getFullYear() === comparing.getFullYear();
}
function isSameMonth(date$1, comparing) {
	return date$1.getMonth() === comparing.getMonth() && date$1.getFullYear() === comparing.getFullYear();
}
function isSameYear(date$1, comparing) {
	return date$1.getFullYear() === comparing.getFullYear();
}
function getDiff(date$1, comparing, unit) {
	const d = new Date(date$1);
	const c = new Date(comparing);
	switch (unit) {
		case "years": return d.getFullYear() - c.getFullYear();
		case "quarters": return Math.floor((d.getMonth() - c.getMonth() + (d.getFullYear() - c.getFullYear()) * 12) / 4);
		case "months": return d.getMonth() - c.getMonth() + (d.getFullYear() - c.getFullYear()) * 12;
		case "weeks": return Math.floor((d.getTime() - c.getTime()) / (1e3 * 60 * 60 * 24 * 7));
		case "days": return Math.floor((d.getTime() - c.getTime()) / (1e3 * 60 * 60 * 24));
		case "hours": return Math.floor((d.getTime() - c.getTime()) / (1e3 * 60 * 60));
		case "minutes": return Math.floor((d.getTime() - c.getTime()) / (1e3 * 60));
		case "seconds": return Math.floor((d.getTime() - c.getTime()) / 1e3);
		default: return d.getTime() - c.getTime();
	}
}
function setHours(date$1, count) {
	const d = new Date(date$1);
	d.setHours(count);
	return d;
}
function setMinutes(date$1, count) {
	const d = new Date(date$1);
	d.setMinutes(count);
	return d;
}
function setMonth(date$1, count) {
	const d = new Date(date$1);
	d.setMonth(count);
	return d;
}
function setDate(date$1, day) {
	const d = new Date(date$1);
	d.setDate(day);
	return d;
}
function setYear(date$1, year) {
	const d = new Date(date$1);
	d.setFullYear(year);
	return d;
}
function startOfDay(date$1) {
	return new Date(date$1.getFullYear(), date$1.getMonth(), date$1.getDate(), 0, 0, 0, 0);
}
function endOfDay(date$1) {
	return new Date(date$1.getFullYear(), date$1.getMonth(), date$1.getDate(), 23, 59, 59, 999);
}
var VuetifyDateAdapter = class {
	constructor(options) {
		this.locale = options.locale;
		this.formats = options.formats;
	}
	date(value) {
		return date(value);
	}
	toJsDate(date$1) {
		return date$1;
	}
	toISO(date$1) {
		return toISO(this, date$1);
	}
	parseISO(date$1) {
		return parseISO(date$1);
	}
	addMinutes(date$1, amount) {
		return addMinutes(date$1, amount);
	}
	addHours(date$1, amount) {
		return addHours(date$1, amount);
	}
	addDays(date$1, amount) {
		return addDays(date$1, amount);
	}
	addWeeks(date$1, amount) {
		return addWeeks(date$1, amount);
	}
	addMonths(date$1, amount) {
		return addMonths(date$1, amount);
	}
	getWeekArray(date$1, firstDayOfWeek) {
		const firstDay = firstDayOfWeek !== void 0 ? Number(firstDayOfWeek) : void 0;
		return getWeekArray(date$1, this.locale, firstDay);
	}
	startOfWeek(date$1, firstDayOfWeek) {
		const firstDay = firstDayOfWeek !== void 0 ? Number(firstDayOfWeek) : void 0;
		return startOfWeek(date$1, this.locale, firstDay);
	}
	endOfWeek(date$1) {
		return endOfWeek(date$1, this.locale);
	}
	startOfMonth(date$1) {
		return startOfMonth(date$1);
	}
	endOfMonth(date$1) {
		return endOfMonth(date$1);
	}
	format(date$1, formatString) {
		return format(date$1, formatString, this.locale, this.formats);
	}
	isEqual(date$1, comparing) {
		return isEqual(date$1, comparing);
	}
	isValid(date$1) {
		return isValid(date$1);
	}
	isWithinRange(date$1, range) {
		return isWithinRange(date$1, range);
	}
	isAfter(date$1, comparing) {
		return isAfter(date$1, comparing);
	}
	isAfterDay(date$1, comparing) {
		return isAfterDay(date$1, comparing);
	}
	isBefore(date$1, comparing) {
		return !isAfter(date$1, comparing) && !isEqual(date$1, comparing);
	}
	isSameDay(date$1, comparing) {
		return isSameDay(date$1, comparing);
	}
	isSameMonth(date$1, comparing) {
		return isSameMonth(date$1, comparing);
	}
	isSameYear(date$1, comparing) {
		return isSameYear(date$1, comparing);
	}
	setMinutes(date$1, count) {
		return setMinutes(date$1, count);
	}
	setHours(date$1, count) {
		return setHours(date$1, count);
	}
	setMonth(date$1, count) {
		return setMonth(date$1, count);
	}
	setDate(date$1, day) {
		return setDate(date$1, day);
	}
	setYear(date$1, year) {
		return setYear(date$1, year);
	}
	getDiff(date$1, comparing, unit) {
		return getDiff(date$1, comparing, unit);
	}
	getWeekdays(firstDayOfWeek, weekdayFormat) {
		const firstDay = firstDayOfWeek !== void 0 ? Number(firstDayOfWeek) : void 0;
		return getWeekdays(this.locale, firstDay, weekdayFormat);
	}
	getYear(date$1) {
		return getYear(date$1);
	}
	getMonth(date$1) {
		return getMonth(date$1);
	}
	getWeek(date$1, firstDayOfWeek, firstWeekMinSize) {
		const firstDay = firstDayOfWeek !== void 0 ? Number(firstDayOfWeek) : void 0;
		return getWeek(date$1, this.locale, firstDay, firstWeekMinSize);
	}
	getDate(date$1) {
		return getDate(date$1);
	}
	getNextMonth(date$1) {
		return getNextMonth(date$1);
	}
	getPreviousMonth(date$1) {
		return getPreviousMonth(date$1);
	}
	getHours(date$1) {
		return getHours(date$1);
	}
	getMinutes(date$1) {
		return getMinutes(date$1);
	}
	startOfDay(date$1) {
		return startOfDay(date$1);
	}
	endOfDay(date$1) {
		return endOfDay(date$1);
	}
	startOfYear(date$1) {
		return startOfYear(date$1);
	}
	endOfYear(date$1) {
		return endOfYear(date$1);
	}
};

//#endregion
//#region node_modules/vuetify/lib/composables/date/date.js
const DateOptionsSymbol = Symbol.for("vuetify:date-options");
const DateAdapterSymbol = Symbol.for("vuetify:date-adapter");
function createDate(options, locale) {
	const _options = mergeDeep({
		adapter: VuetifyDateAdapter,
		locale: {
			af: "af-ZA",
			bg: "bg-BG",
			ca: "ca-ES",
			ckb: "",
			cs: "cs-CZ",
			de: "de-DE",
			el: "el-GR",
			en: "en-US",
			et: "et-EE",
			fa: "fa-IR",
			fi: "fi-FI",
			hr: "hr-HR",
			hu: "hu-HU",
			he: "he-IL",
			id: "id-ID",
			it: "it-IT",
			ja: "ja-JP",
			ko: "ko-KR",
			lv: "lv-LV",
			lt: "lt-LT",
			nl: "nl-NL",
			no: "no-NO",
			pl: "pl-PL",
			pt: "pt-PT",
			ro: "ro-RO",
			ru: "ru-RU",
			sk: "sk-SK",
			sl: "sl-SI",
			srCyrl: "sr-SP",
			srLatn: "sr-SP",
			sv: "sv-SE",
			th: "th-TH",
			tr: "tr-TR",
			az: "az-AZ",
			uk: "uk-UA",
			vi: "vi-VN",
			zhHans: "zh-CN",
			zhHant: "zh-TW"
		}
	}, options);
	return {
		options: _options,
		instance: createInstance(_options, locale)
	};
}
function createDateRange(adapter, start, stop) {
	const diff = adapter.getDiff(adapter.endOfDay(stop ?? start), adapter.startOfDay(start), "days");
	const datesInRange = [start];
	for (let i = 1; i < diff; i++) {
		const nextDate = adapter.addDays(start, i);
		datesInRange.push(nextDate);
	}
	if (stop) datesInRange.push(adapter.endOfDay(stop));
	return datesInRange;
}
function createInstance(options, locale) {
	const instance = reactive(typeof options.adapter === "function" ? new options.adapter({
		locale: options.locale[locale.current.value] ?? locale.current.value,
		formats: options.formats
	}) : options.adapter);
	watch(locale.current, (value) => {
		instance.locale = options.locale[value] ?? value ?? instance.locale;
	});
	return instance;
}
function useDate() {
	const options = inject(DateOptionsSymbol);
	if (!options) throw new Error("[Vuetify] Could not find injected date options");
	const locale = useLocale();
	return createInstance(options, locale);
}

//#endregion
//#region node_modules/vuetify/lib/composables/goto.js
const GoToSymbol = Symbol.for("vuetify:goto");
function genDefaults() {
	return {
		container: void 0,
		duration: 300,
		layout: false,
		offset: 0,
		easing: "easeInOutCubic",
		patterns: {
			linear: (t) => t,
			easeInQuad: (t) => t ** 2,
			easeOutQuad: (t) => t * (2 - t),
			easeInOutQuad: (t) => t < .5 ? 2 * t ** 2 : -1 + (4 - 2 * t) * t,
			easeInCubic: (t) => t ** 3,
			easeOutCubic: (t) => --t ** 3 + 1,
			easeInOutCubic: (t) => t < .5 ? 4 * t ** 3 : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
			easeInQuart: (t) => t ** 4,
			easeOutQuart: (t) => 1 - --t ** 4,
			easeInOutQuart: (t) => t < .5 ? 8 * t ** 4 : 1 - 8 * --t ** 4,
			easeInQuint: (t) => t ** 5,
			easeOutQuint: (t) => 1 + --t ** 5,
			easeInOutQuint: (t) => t < .5 ? 16 * t ** 5 : 1 + 16 * --t ** 5
		}
	};
}
function getContainer(el) {
	return getTarget(el) ?? (document.scrollingElement || document.body);
}
function getTarget(el) {
	return typeof el === "string" ? document.querySelector(el) : refElement(el);
}
function getOffset(target, horizontal, rtl) {
	if (typeof target === "number") return horizontal && rtl ? -target : target;
	let el = getTarget(target);
	let totalOffset = 0;
	while (el) {
		totalOffset += horizontal ? el.offsetLeft : el.offsetTop;
		el = el.offsetParent;
	}
	return totalOffset;
}
function createGoTo(options, locale) {
	return {
		rtl: locale.isRtl,
		options: mergeDeep(genDefaults(), options)
	};
}
async function scrollTo(_target, _options, horizontal, goTo) {
	const property = horizontal ? "scrollLeft" : "scrollTop";
	const options = mergeDeep(goTo?.options ?? genDefaults(), _options);
	const rtl = goTo?.rtl.value;
	const target = (typeof _target === "number" ? _target : getTarget(_target)) ?? 0;
	const container = options.container === "parent" && target instanceof HTMLElement ? target.parentElement : getContainer(options.container);
	const ease = typeof options.easing === "function" ? options.easing : options.patterns[options.easing];
	if (!ease) throw new TypeError(`Easing function "${options.easing}" not found.`);
	let targetLocation;
	if (typeof target === "number") targetLocation = getOffset(target, horizontal, rtl);
	else {
		targetLocation = getOffset(target, horizontal, rtl) - getOffset(container, horizontal, rtl);
		if (options.layout) {
			const styles = window.getComputedStyle(target);
			const layoutOffset = styles.getPropertyValue("--v-layout-top");
			if (layoutOffset) targetLocation -= parseInt(layoutOffset, 10);
		}
	}
	targetLocation += options.offset;
	targetLocation = clampTarget(container, targetLocation, !!rtl, !!horizontal);
	const startLocation = container[property] ?? 0;
	if (targetLocation === startLocation) return Promise.resolve(targetLocation);
	const startTime = performance.now();
	return new Promise((resolve) => requestAnimationFrame(function step(currentTime) {
		const timeElapsed = currentTime - startTime;
		const progress = timeElapsed / options.duration;
		const location = Math.floor(startLocation + (targetLocation - startLocation) * ease(clamp(progress, 0, 1)));
		container[property] = location;
		if (progress >= 1 && Math.abs(location - container[property]) < 10) return resolve(targetLocation);
		else if (progress > 2) {
			consoleWarn("Scroll target is not reachable");
			return resolve(container[property]);
		}
		requestAnimationFrame(step);
	}));
}
function useGoTo() {
	let _options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
	const goToInstance = inject(GoToSymbol);
	const { isRtl } = useRtl();
	if (!goToInstance) throw new Error("[Vuetify] Could not find injected goto instance");
	const goTo = {
		...goToInstance,
		rtl: toRef(() => goToInstance.rtl.value || isRtl.value)
	};
	async function go(target, options) {
		return scrollTo(target, mergeDeep(_options, options), false, goTo);
	}
	go.horizontal = async (target, options) => {
		return scrollTo(target, mergeDeep(_options, options), true, goTo);
	};
	return go;
}
/**
* Clamp target value to achieve a smooth scroll animation
* when the value goes outside the scroll container size
*/
function clampTarget(container, value, rtl, horizontal) {
	const { scrollWidth, scrollHeight } = container;
	const [containerWidth, containerHeight] = container === document.scrollingElement ? [window.innerWidth, window.innerHeight] : [container.offsetWidth, container.offsetHeight];
	let min;
	let max;
	if (horizontal) if (rtl) {
		min = -(scrollWidth - containerWidth);
		max = 0;
	} else {
		min = 0;
		max = scrollWidth - containerWidth;
	}
	else {
		min = 0;
		max = scrollHeight + -containerHeight;
	}
	return clamp(value, min, max);
}

//#endregion
//#region node_modules/vuetify/lib/composables/resizeObserver.js
function useResizeObserver(callback) {
	let box = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "content";
	const resizeRef = templateRef();
	const contentRect = ref();
	if (IN_BROWSER) {
		const observer = new ResizeObserver((entries) => {
			callback?.(entries, observer);
			if (!entries.length) return;
			if (box === "content") contentRect.value = entries[0].contentRect;
			else contentRect.value = entries[0].target.getBoundingClientRect();
		});
		onBeforeUnmount(() => {
			observer.disconnect();
		});
		watch(() => resizeRef.el, (newValue, oldValue) => {
			if (oldValue) {
				observer.unobserve(oldValue);
				contentRect.value = void 0;
			}
			if (newValue) observer.observe(newValue);
		}, { flush: "post" });
	}
	return {
		resizeRef,
		contentRect: readonly(contentRect)
	};
}

//#endregion
//#region node_modules/vuetify/lib/composables/layout.js
const VuetifyLayoutKey = Symbol.for("vuetify:layout");
const VuetifyLayoutItemKey = Symbol.for("vuetify:layout-item");
const ROOT_ZINDEX = 1e3;
const makeLayoutProps = propsFactory({
	overlaps: {
		type: Array,
		default: () => []
	},
	fullHeight: Boolean
}, "layout");
const makeLayoutItemProps = propsFactory({
	name: { type: String },
	order: {
		type: [Number, String],
		default: 0
	},
	absolute: Boolean
}, "layout-item");
function useLayout() {
	const layout = inject(VuetifyLayoutKey);
	if (!layout) throw new Error("[Vuetify] Could not find injected layout");
	return {
		getLayoutItem: layout.getLayoutItem,
		mainRect: layout.mainRect,
		mainStyles: layout.mainStyles
	};
}
function useLayoutItem(options) {
	const layout = inject(VuetifyLayoutKey);
	if (!layout) throw new Error("[Vuetify] Could not find injected layout");
	const id = options.id ?? `layout-item-${useId()}`;
	const vm = getCurrentInstance("useLayoutItem");
	provide(VuetifyLayoutItemKey, { id });
	const isKeptAlive = shallowRef(false);
	onDeactivated(() => isKeptAlive.value = true);
	onActivated(() => isKeptAlive.value = false);
	const { layoutItemStyles, layoutItemScrimStyles } = layout.register(vm, {
		...options,
		active: computed(() => isKeptAlive.value ? false : options.active.value),
		id
	});
	onBeforeUnmount(() => layout.unregister(id));
	return {
		layoutItemStyles,
		layoutRect: layout.layoutRect,
		layoutItemScrimStyles
	};
}
const generateLayers = (layout, positions, layoutSizes, activeItems) => {
	let previousLayer = {
		top: 0,
		left: 0,
		right: 0,
		bottom: 0
	};
	const layers = [{
		id: "",
		layer: { ...previousLayer }
	}];
	for (const id of layout) {
		const position = positions.get(id);
		const amount = layoutSizes.get(id);
		const active = activeItems.get(id);
		if (!position || !amount || !active) continue;
		const layer = {
			...previousLayer,
			[position.value]: parseInt(previousLayer[position.value], 10) + (active.value ? parseInt(amount.value, 10) : 0)
		};
		layers.push({
			id,
			layer
		});
		previousLayer = layer;
	}
	return layers;
};
function createLayout(props) {
	const parentLayout = inject(VuetifyLayoutKey, null);
	const rootZIndex = computed(() => parentLayout ? parentLayout.rootZIndex.value - 100 : ROOT_ZINDEX);
	const registered = ref([]);
	const positions = reactive(/* @__PURE__ */ new Map());
	const layoutSizes = reactive(/* @__PURE__ */ new Map());
	const priorities = reactive(/* @__PURE__ */ new Map());
	const activeItems = reactive(/* @__PURE__ */ new Map());
	const disabledTransitions = reactive(/* @__PURE__ */ new Map());
	const { resizeRef, contentRect: layoutRect } = useResizeObserver();
	const computedOverlaps = computed(() => {
		const map = /* @__PURE__ */ new Map();
		const overlaps = props.overlaps ?? [];
		for (const overlap of overlaps.filter((item) => item.includes(":"))) {
			const [top, bottom] = overlap.split(":");
			if (!registered.value.includes(top) || !registered.value.includes(bottom)) continue;
			const topPosition = positions.get(top);
			const bottomPosition = positions.get(bottom);
			const topAmount = layoutSizes.get(top);
			const bottomAmount = layoutSizes.get(bottom);
			if (!topPosition || !bottomPosition || !topAmount || !bottomAmount) continue;
			map.set(bottom, {
				position: topPosition.value,
				amount: parseInt(topAmount.value, 10)
			});
			map.set(top, {
				position: bottomPosition.value,
				amount: -parseInt(bottomAmount.value, 10)
			});
		}
		return map;
	});
	const layers = computed(() => {
		const uniquePriorities = [...new Set([...priorities.values()].map((p) => p.value))].sort((a, b) => a - b);
		const layout = [];
		for (const p of uniquePriorities) {
			const items$1 = registered.value.filter((id) => priorities.get(id)?.value === p);
			layout.push(...items$1);
		}
		return generateLayers(layout, positions, layoutSizes, activeItems);
	});
	const transitionsEnabled = computed(() => {
		return !Array.from(disabledTransitions.values()).some((ref$1) => ref$1.value);
	});
	const mainRect = computed(() => {
		return layers.value[layers.value.length - 1].layer;
	});
	const mainStyles = toRef(() => {
		return {
			"--v-layout-left": convertToUnit(mainRect.value.left),
			"--v-layout-right": convertToUnit(mainRect.value.right),
			"--v-layout-top": convertToUnit(mainRect.value.top),
			"--v-layout-bottom": convertToUnit(mainRect.value.bottom),
			...transitionsEnabled.value ? void 0 : { transition: "none" }
		};
	});
	const items = computed(() => {
		return layers.value.slice(1).map((_ref, index) => {
			let { id } = _ref;
			const { layer } = layers.value[index];
			const size = layoutSizes.get(id);
			const position = positions.get(id);
			return {
				id,
				...layer,
				size: Number(size.value),
				position: position.value
			};
		});
	});
	const getLayoutItem = (id) => {
		return items.value.find((item) => item.id === id);
	};
	const rootVm = getCurrentInstance("createLayout");
	const isMounted = shallowRef(false);
	onMounted(() => {
		isMounted.value = true;
	});
	provide(VuetifyLayoutKey, {
		register: (vm, _ref2) => {
			let { id, order, position, layoutSize, elementSize, active, disableTransitions, absolute } = _ref2;
			priorities.set(id, order);
			positions.set(id, position);
			layoutSizes.set(id, layoutSize);
			activeItems.set(id, active);
			disableTransitions && disabledTransitions.set(id, disableTransitions);
			const instances = findChildrenWithProvide(VuetifyLayoutItemKey, rootVm?.vnode);
			const instanceIndex = instances.indexOf(vm);
			if (instanceIndex > -1) registered.value.splice(instanceIndex, 0, id);
			else registered.value.push(id);
			const index = computed(() => items.value.findIndex((i) => i.id === id));
			const zIndex = computed(() => rootZIndex.value + layers.value.length * 2 - index.value * 2);
			const layoutItemStyles = computed(() => {
				const isHorizontal = position.value === "left" || position.value === "right";
				const isOppositeHorizontal = position.value === "right";
				const isOppositeVertical = position.value === "bottom";
				const size = elementSize.value ?? layoutSize.value;
				const unit = size === 0 ? "%" : "px";
				const styles = {
					[position.value]: 0,
					zIndex: zIndex.value,
					transform: `translate${isHorizontal ? "X" : "Y"}(${(active.value ? 0 : -(size === 0 ? 100 : size)) * (isOppositeHorizontal || isOppositeVertical ? -1 : 1)}${unit})`,
					position: absolute.value || rootZIndex.value !== ROOT_ZINDEX ? "absolute" : "fixed",
					...transitionsEnabled.value ? void 0 : { transition: "none" }
				};
				if (!isMounted.value) return styles;
				const item = items.value[index.value];
				if (!item) throw new Error(`[Vuetify] Could not find layout item "${id}"`);
				const overlap = computedOverlaps.value.get(id);
				if (overlap) item[overlap.position] += overlap.amount;
				return {
					...styles,
					height: isHorizontal ? `calc(100% - ${item.top}px - ${item.bottom}px)` : elementSize.value ? `${elementSize.value}px` : void 0,
					left: isOppositeHorizontal ? void 0 : `${item.left}px`,
					right: isOppositeHorizontal ? `${item.right}px` : void 0,
					top: position.value !== "bottom" ? `${item.top}px` : void 0,
					bottom: position.value !== "top" ? `${item.bottom}px` : void 0,
					width: !isHorizontal ? `calc(100% - ${item.left}px - ${item.right}px)` : elementSize.value ? `${elementSize.value}px` : void 0
				};
			});
			const layoutItemScrimStyles = computed(() => ({ zIndex: zIndex.value - 1 }));
			return {
				layoutItemStyles,
				layoutItemScrimStyles,
				zIndex
			};
		},
		unregister: (id) => {
			priorities.delete(id);
			positions.delete(id);
			layoutSizes.delete(id);
			activeItems.delete(id);
			disabledTransitions.delete(id);
			registered.value = registered.value.filter((v) => v !== id);
		},
		mainRect,
		mainStyles,
		getLayoutItem,
		items,
		layoutRect,
		rootZIndex
	});
	const layoutClasses = toRef(() => ["v-layout", { "v-layout--full-height": props.fullHeight }]);
	const layoutStyles = toRef(() => ({
		zIndex: parentLayout ? rootZIndex.value : void 0,
		position: parentLayout ? "relative" : void 0,
		overflow: parentLayout ? "hidden" : void 0
	}));
	return {
		layoutClasses,
		layoutStyles,
		getLayoutItem,
		items,
		layoutRect,
		layoutRef: resizeRef
	};
}

//#endregion
export { DateAdapterSymbol, DateOptionsSymbol, GoToSymbol, VuetifyLayoutKey, createDate, createDateRange, createGoTo, createLayout, makeLayoutItemProps, makeLayoutProps, useDate, useGoTo, useLayout, useLayoutItem, useResizeObserver };
//# sourceMappingURL=layout-1FEB3q0s.js.map