import { effectScope, nextTick, onBeforeUnmount, reactive, toValue, watch } from "./vue.runtime.esm-bundler-CvPjzdzA.js";
import { DefaultsSymbol, IN_BROWSER, consoleWarn, createDefaults, defineComponent, getCurrentInstance, mergeDeep, useDefaults } from "./defineComponent-CAKzfwnn.js";
import { DisplaySymbol, LocaleSymbol, ThemeSymbol, createDisplay, createLocale, createTheme, useDisplay, useLocale, useRtl, useTheme } from "./theme-8uHrIPrN.js";
import { IconSymbol, createIcons } from "./mdi-UielyH1A.js";
import { DateAdapterSymbol, DateOptionsSymbol, GoToSymbol, createDate, createGoTo, useDate, useGoTo, useLayout } from "./layout-1FEB3q0s.js";

//#region node_modules/vuetify/lib/composables/hotkey/key-aliases.js
/**
* Centralized key alias mapping for consistent key normalization across the hotkey system.
*
* This maps various user-friendly aliases to canonical key names that match
* KeyboardEvent.key values (in lowercase) where possible.
*/
const keyAliasMap = {
	control: "ctrl",
	command: "cmd",
	option: "alt",
	up: "arrowup",
	down: "arrowdown",
	left: "arrowleft",
	right: "arrowright",
	esc: "escape",
	spacebar: " ",
	space: " ",
	return: "enter",
	del: "delete",
	minus: "-",
	hyphen: "-"
};
/**
* Normalizes a key string to its canonical form using the alias map.
*
* @param key - The key string to normalize
* @returns The canonical key name in lowercase
*/
function normalizeKey(key) {
	const lowerKey = key.toLowerCase();
	return keyAliasMap[lowerKey] || lowerKey;
}

//#endregion
//#region node_modules/vuetify/lib/composables/hotkey/hotkey-parsing.js
/**
* Splits a single combination string into individual key parts.
*
* A combination is a set of keys that must be pressed simultaneously.
* e.g. `ctrl+k`, `shift--`
*/
function splitKeyCombination(combination) {
	let isInternal = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
	if (!combination) {
		if (!isInternal) consoleWarn("Invalid hotkey combination: empty string provided");
		return [];
	}
	const startsWithPlusOrUnderscore = combination.startsWith("+") || combination.startsWith("_");
	const hasInvalidLeadingSeparator = startsWithPlusOrUnderscore && !(combination.startsWith("++") || combination.startsWith("__"));
	const hasInvalidStructure = combination.length > 1 && hasInvalidLeadingSeparator || combination.includes("++") || combination.includes("__") || combination === "+" || combination === "_" || combination.length > 1 && (combination.endsWith("+") || combination.endsWith("_")) && combination.at(-2) !== combination.at(-1) || combination === "++" || combination === "--" || combination === "__";
	if (hasInvalidStructure) {
		if (!isInternal) consoleWarn(`Invalid hotkey combination: "${combination}" has invalid structure`);
		return [];
	}
	const keys = [];
	let buffer = "";
	const flushBuffer = () => {
		if (buffer) {
			keys.push(normalizeKey(buffer));
			buffer = "";
		}
	};
	for (let i = 0; i < combination.length; i++) {
		const char = combination[i];
		const nextChar = combination[i + 1];
		if (char === "+" || char === "_" || char === "-") if (char === nextChar) {
			flushBuffer();
			keys.push(char);
			i++;
		} else if (char === "+" || char === "_") flushBuffer();
		else buffer += char;
		else buffer += char;
	}
	flushBuffer();
	const hasInvalidMinus = keys.some((key) => key.length > 1 && key.includes("-") && key !== "--");
	if (hasInvalidMinus) {
		if (!isInternal) consoleWarn(`Invalid hotkey combination: "${combination}" has invalid structure`);
		return [];
	}
	if (keys.length === 0 && combination) return [normalizeKey(combination)];
	return keys;
}
/**
* Splits a hotkey string into its constituent combination groups.
*
* A sequence is a series of combinations that must be pressed in order.
* e.g. `a-b`, `ctrl+k-p`
*/
function splitKeySequence(str) {
	if (!str) {
		consoleWarn("Invalid hotkey sequence: empty string provided");
		return [];
	}
	const hasInvalidStart = str.startsWith("-") && !["---", "--+"].includes(str);
	const hasInvalidEnd = str.endsWith("-") && !str.endsWith("+-") && !str.endsWith("_-") && str !== "-" && str !== "---";
	if (hasInvalidStart || hasInvalidEnd) {
		consoleWarn(`Invalid hotkey sequence: "${str}" contains invalid combinations`);
		return [];
	}
	const result = [];
	let buffer = "";
	let i = 0;
	while (i < str.length) {
		const char = str[i];
		if (char === "-") {
			const prevChar = str[i - 1];
			const prevPrevChar = i > 1 ? str[i - 2] : void 0;
			const precededBySinglePlusOrUnderscore = (prevChar === "+" || prevChar === "_") && prevPrevChar !== "+";
			if (precededBySinglePlusOrUnderscore) {
				buffer += char;
				i++;
			} else {
				if (buffer) {
					result.push(buffer);
					buffer = "";
				} else result.push("-");
				i++;
			}
		} else {
			buffer += char;
			i++;
		}
	}
	if (buffer) result.push(buffer);
	const collapsed = [];
	let minusCount = 0;
	for (const part of result) if (part === "-") {
		if (minusCount % 2 === 0) collapsed.push("-");
		minusCount++;
	} else {
		minusCount = 0;
		collapsed.push(part);
	}
	const areAllValid = collapsed.every((s) => splitKeyCombination(s, true).length > 0);
	if (!areAllValid) {
		consoleWarn(`Invalid hotkey sequence: "${str}" contains invalid combinations`);
		return [];
	}
	return collapsed;
}

//#endregion
//#region node_modules/vuetify/lib/composables/hotkey/hotkey.js
function useHotkey(keys, callback) {
	let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
	if (!IN_BROWSER) return function() {};
	const { event = "keydown", inputs = false, preventDefault = true, sequenceTimeout = 1e3 } = options;
	const isMac = navigator?.userAgent?.includes("Macintosh") ?? false;
	let timeout = 0;
	let keyGroups;
	let isSequence = false;
	let groupIndex = 0;
	function clearTimer() {
		if (!timeout) return;
		clearTimeout(timeout);
		timeout = 0;
	}
	function isInputFocused() {
		if (toValue(inputs)) return false;
		const activeElement = document.activeElement;
		return activeElement && (activeElement.tagName === "INPUT" || activeElement.tagName === "TEXTAREA" || activeElement.isContentEditable || activeElement.contentEditable === "true");
	}
	function resetSequence() {
		groupIndex = 0;
		clearTimer();
	}
	function handler(e) {
		const group = keyGroups[groupIndex];
		if (!group || isInputFocused()) return;
		if (!matchesKeyGroup(e, group)) {
			if (isSequence) resetSequence();
			return;
		}
		if (toValue(preventDefault)) e.preventDefault();
		if (!isSequence) {
			callback(e);
			return;
		}
		clearTimer();
		groupIndex++;
		if (groupIndex === keyGroups.length) {
			callback(e);
			resetSequence();
			return;
		}
		timeout = window.setTimeout(resetSequence, toValue(sequenceTimeout));
	}
	function cleanup() {
		window.removeEventListener(toValue(event), handler);
		clearTimer();
	}
	watch(() => toValue(keys), function(unrefKeys) {
		cleanup();
		if (unrefKeys) {
			const groups = splitKeySequence(unrefKeys.toLowerCase());
			isSequence = groups.length > 1;
			keyGroups = groups;
			resetSequence();
			window.addEventListener(toValue(event), handler);
		}
	}, { immediate: true });
	watch(() => toValue(event), function(newEvent, oldEvent) {
		if (oldEvent && keyGroups && keyGroups.length > 0) {
			window.removeEventListener(oldEvent, handler);
			window.addEventListener(newEvent, handler);
		}
	});
	try {
		getCurrentInstance("useHotkey");
		onBeforeUnmount(cleanup);
	} catch {}
	function parseKeyGroup(group) {
		const MODIFIERS = [
			"ctrl",
			"shift",
			"alt",
			"meta",
			"cmd"
		];
		const parts = splitKeyCombination(group.toLowerCase());
		if (parts.length === 0) return {
			modifiers: Object.fromEntries(MODIFIERS.map((m) => [m, false])),
			actualKey: void 0
		};
		const modifiers = Object.fromEntries(MODIFIERS.map((m) => [m, false]));
		let actualKey;
		for (const part of parts) if (MODIFIERS.includes(part)) modifiers[part] = true;
		else actualKey = part;
		return {
			modifiers,
			actualKey
		};
	}
	function matchesKeyGroup(e, group) {
		const { modifiers, actualKey } = parseKeyGroup(group);
		const expectCtrl = modifiers.ctrl || !isMac && (modifiers.cmd || modifiers.meta);
		const expectMeta = isMac && (modifiers.cmd || modifiers.meta);
		return e.ctrlKey === expectCtrl && e.metaKey === expectMeta && e.shiftKey === modifiers.shift && e.altKey === modifiers.alt && e.key.toLowerCase() === actualKey?.toLowerCase();
	}
	return cleanup;
}

//#endregion
//#region node_modules/vuetify/lib/framework.js
function createVuetify() {
	let vuetify = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
	const { blueprint,...rest } = vuetify;
	const options = mergeDeep(blueprint, rest);
	const { aliases = {}, components = {}, directives = {} } = options;
	const scope = effectScope();
	return scope.run(() => {
		const defaults = createDefaults(options.defaults);
		const display = createDisplay(options.display, options.ssr);
		const theme = createTheme(options.theme);
		const icons = createIcons(options.icons);
		const locale = createLocale(options.locale);
		const date = createDate(options.date, locale);
		const goTo = createGoTo(options.goTo, locale);
		function install(app) {
			for (const key in directives) app.directive(key, directives[key]);
			for (const key in components) app.component(key, components[key]);
			for (const key in aliases) app.component(key, defineComponent({
				...aliases[key],
				name: key,
				aliasName: aliases[key].name
			}));
			const appScope = effectScope();
			appScope.run(() => {
				theme.install(app);
			});
			app.onUnmount(() => appScope.stop());
			app.provide(DefaultsSymbol, defaults);
			app.provide(DisplaySymbol, display);
			app.provide(ThemeSymbol, theme);
			app.provide(IconSymbol, icons);
			app.provide(LocaleSymbol, locale);
			app.provide(DateOptionsSymbol, date.options);
			app.provide(DateAdapterSymbol, date.instance);
			app.provide(GoToSymbol, goTo);
			if (IN_BROWSER && options.ssr) if (app.$nuxt) app.$nuxt.hook("app:suspense:resolve", () => {
				display.update();
			});
			else {
				const { mount } = app;
				app.mount = function() {
					const vm = mount(...arguments);
					nextTick(() => display.update());
					app.mount = mount;
					return vm;
				};
			}
			if (typeof __VUE_OPTIONS_API__ !== "boolean" || __VUE_OPTIONS_API__) app.mixin({ computed: { $vuetify() {
				return reactive({
					defaults: inject.call(this, DefaultsSymbol),
					display: inject.call(this, DisplaySymbol),
					theme: inject.call(this, ThemeSymbol),
					icons: inject.call(this, IconSymbol),
					locale: inject.call(this, LocaleSymbol),
					date: inject.call(this, DateAdapterSymbol)
				});
			} } });
		}
		function unmount() {
			scope.stop();
		}
		return {
			install,
			unmount,
			defaults,
			display,
			theme,
			icons,
			locale,
			date,
			goTo
		};
	});
}
const version = "3.9.0";
createVuetify.version = version;
function inject(key) {
	const vm = this.$;
	const provides = vm.parent?.provides ?? vm.vnode.appContext?.provides;
	if (provides && key in provides) return provides[key];
}

//#endregion
export { createVuetify, useDate, useDefaults, useDisplay, useGoTo, useHotkey, useLayout, useLocale, useRtl, useTheme, version };
//# sourceMappingURL=vuetify.js.map