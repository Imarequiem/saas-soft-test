import { h, mergeProps, render, resolveComponent } from "./vue.runtime.esm-bundler-CvPjzdzA.js";
import { consoleError, isObject } from "./defineComponent-CAKzfwnn.js";
import { ClickOutside, Intersect, Ripple, Touch, VTooltip } from "./VTooltip-E7x0-xqA.js";
import "./theme-8uHrIPrN.js";

//#region node_modules/vuetify/lib/directives/mutate/index.js
function mounted$2(el, binding) {
	const modifiers = binding.modifiers || {};
	const value = binding.value;
	const { once, immediate,...modifierKeys } = modifiers;
	const defaultValue = !Object.keys(modifierKeys).length;
	const { handler, options } = typeof value === "object" ? value : {
		handler: value,
		options: {
			attributes: modifierKeys?.attr ?? defaultValue,
			characterData: modifierKeys?.char ?? defaultValue,
			childList: modifierKeys?.child ?? defaultValue,
			subtree: modifierKeys?.sub ?? defaultValue
		}
	};
	const observer = new MutationObserver(function() {
		let mutations = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
		let observer$1 = arguments.length > 1 ? arguments[1] : void 0;
		handler?.(mutations, observer$1);
		if (once) unmounted$2(el, binding);
	});
	if (immediate) handler?.([], observer);
	el._mutate = Object(el._mutate);
	el._mutate[binding.instance.$.uid] = { observer };
	observer.observe(el, options);
}
function unmounted$2(el, binding) {
	if (!el._mutate?.[binding.instance.$.uid]) return;
	el._mutate[binding.instance.$.uid].observer.disconnect();
	delete el._mutate[binding.instance.$.uid];
}
const Mutate = {
	mounted: mounted$2,
	unmounted: unmounted$2
};

//#endregion
//#region node_modules/vuetify/lib/directives/resize/index.js
function mounted$1(el, binding) {
	const handler = binding.value;
	const options = { passive: !binding.modifiers?.active };
	window.addEventListener("resize", handler, options);
	el._onResize = Object(el._onResize);
	el._onResize[binding.instance.$.uid] = {
		handler,
		options
	};
	if (!binding.modifiers?.quiet) handler();
}
function unmounted$1(el, binding) {
	if (!el._onResize?.[binding.instance.$.uid]) return;
	const { handler, options } = el._onResize[binding.instance.$.uid];
	window.removeEventListener("resize", handler, options);
	delete el._onResize[binding.instance.$.uid];
}
const Resize = {
	mounted: mounted$1,
	unmounted: unmounted$1
};

//#endregion
//#region node_modules/vuetify/lib/directives/scroll/index.js
function mounted(el, binding) {
	const { self = false } = binding.modifiers ?? {};
	const value = binding.value;
	const options = typeof value === "object" && value.options || { passive: true };
	const handler = typeof value === "function" || "handleEvent" in value ? value : value.handler;
	const target = self ? el : binding.arg ? document.querySelector(binding.arg) : window;
	if (!target) return;
	target.addEventListener("scroll", handler, options);
	el._onScroll = Object(el._onScroll);
	el._onScroll[binding.instance.$.uid] = {
		handler,
		options,
		target: self ? void 0 : target
	};
}
function unmounted(el, binding) {
	if (!el._onScroll?.[binding.instance.$.uid]) return;
	const { handler, options, target = el } = el._onScroll[binding.instance.$.uid];
	target.removeEventListener("scroll", handler, options);
	delete el._onScroll[binding.instance.$.uid];
}
function updated(el, binding) {
	if (binding.value === binding.oldValue) return;
	unmounted(el, binding);
	mounted(el, binding);
}
const Scroll = {
	mounted,
	unmounted,
	updated
};

//#endregion
//#region node_modules/vuetify/lib/composables/directiveComponent.js
function useDirectiveComponent(component, props) {
	const concreteComponent = typeof component === "string" ? resolveComponent(component) : component;
	const hook = mountComponent(concreteComponent, props);
	return {
		mounted: hook,
		updated: hook,
		unmounted(el) {
			render(null, el);
		}
	};
}
function mountComponent(component, props) {
	return function(el, binding, vnode) {
		const _props = typeof props === "function" ? props(binding) : props;
		const text = binding.value?.text ?? binding.value ?? _props?.text;
		const value = isObject(binding.value) ? binding.value : {};
		const children = () => text ?? el.textContent;
		const provides = (vnode.ctx === binding.instance.$ ? findComponentParent(vnode, binding.instance.$)?.provides : vnode.ctx?.provides) ?? binding.instance.$.provides;
		const node = h(component, mergeProps(_props, value), children);
		node.appContext = Object.assign(Object.create(null), binding.instance.$.appContext, { provides });
		render(node, el);
	};
}
function findComponentParent(vnode, root) {
	const stack = /* @__PURE__ */ new Set();
	const walk = (children) => {
		for (const child of children) {
			if (!child) continue;
			if (child === vnode || child.el && vnode.el && child.el === vnode.el) return true;
			stack.add(child);
			let result$1;
			if (child.suspense) result$1 = walk([child.ssContent]);
			else if (Array.isArray(child.children)) result$1 = walk(child.children);
			else if (child.component?.vnode) result$1 = walk([child.component?.subTree]);
			if (result$1) return result$1;
			stack.delete(child);
		}
		return false;
	};
	if (!walk([root.subTree])) {
		consoleError("Could not find original vnode, component will not inherit provides");
		return root;
	}
	const result = Array.from(stack).reverse();
	for (const child of result) if (child.component) return child.component;
	return root;
}

//#endregion
//#region node_modules/vuetify/lib/directives/tooltip/index.js
const Tooltip = useDirectiveComponent(VTooltip, (binding) => {
	return {
		activator: "parent",
		location: binding.arg?.replace("-", " "),
		text: typeof binding.value === "boolean" ? void 0 : binding.value
	};
});

//#endregion
export { ClickOutside, Intersect, Mutate, Resize, Ripple, Scroll, Tooltip, Touch };
//# sourceMappingURL=vuetify_directives.js.map